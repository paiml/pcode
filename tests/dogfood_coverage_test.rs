// Tests generated by pcode to improve its own coverage
use pcode::{
    config::Config,
    mcp::{
        protocol::{Message, ProtocolHandler},
        McpError,
    },
    security::SecurityError,
    tools::ToolError,
    PcodeError,
};

#[test]
fn test_all_error_conversions() {
    // Test all From implementations for PcodeError
    let mcp_err = McpError::Protocol("test".to_string());
    let pcode_err: PcodeError = mcp_err.into();
    assert!(matches!(pcode_err, PcodeError::Mcp(_)));

    let tool_err = ToolError::NotFound("test".to_string());
    let pcode_err: PcodeError = tool_err.into();
    assert!(matches!(pcode_err, PcodeError::Tool(_)));
}

#[test]
fn test_all_error_displays() {
    // Test all error Display implementations
    let err = PcodeError::Runtime(pcode::runtime::RuntimeError::Execution("test".to_string()));
    assert!(err.to_string().contains("Runtime error"));

    let err = PcodeError::Security(SecurityError::UnsupportedPlatform);
    assert!(err.to_string().contains("Security error"));

    let err = PcodeError::Mcp(McpError::Serialization("test".to_string()));
    assert!(err.to_string().contains("MCP protocol error"));

    let err = PcodeError::Tool(ToolError::PermissionDenied("test".to_string()));
    assert!(err.to_string().contains("Tool error"));
}

#[test]
fn test_config_has_api_key_with_key() {
    std::env::set_var("AI_STUDIO_API_KEY", "test_key");
    let config = Config::from_env();
    assert!(config.has_api_key());
    assert_eq!(config.ai_studio_api_key, Some("test_key".to_string()));
    std::env::remove_var("AI_STUDIO_API_KEY");
}

#[test]
fn test_protocol_handler_large_message() {
    let handler = ProtocolHandler::new();
    let large_payload = vec![0xAB; 10000]; // 10KB payload
    let message = Message {
        id: u64::MAX,
        payload: large_payload.clone(),
    };

    let encoded = handler.encode_message(&message).unwrap();
    let decoded = handler.decode_message(&encoded).unwrap();

    assert_eq!(decoded.id, u64::MAX);
    assert_eq!(decoded.payload, large_payload);
}

#[test]
fn test_protocol_handler_empty_message() {
    let handler = ProtocolHandler::new();
    let message = Message {
        id: 0,
        payload: vec![],
    };

    let encoded = handler.encode_message(&message).unwrap();
    assert_eq!(encoded.len(), 12); // 8 bytes id + 4 bytes length

    let decoded = handler.decode_message(&encoded).unwrap();
    assert_eq!(decoded.id, 0);
    assert!(decoded.payload.is_empty());
}

#[test]
fn test_mcp_error_variants() {
    let err = McpError::Transport("transport fail".to_string());
    assert_eq!(err.to_string(), "Transport error: transport fail");

    let err = McpError::Serialization("json fail".to_string());
    assert_eq!(err.to_string(), "Serialization error: json fail");
}

#[test]
fn test_security_error_display() {
    let err = SecurityError::InitError("sandbox failed".to_string());
    assert!(err.to_string().contains("Failed to initialize sandbox"));

    let err = SecurityError::PermissionDenied("no access".to_string());
    assert!(err.to_string().contains("Permission denied"));

    let err = SecurityError::UnsupportedPlatform;
    assert!(err.to_string().contains("Unsupported platform"));
}
